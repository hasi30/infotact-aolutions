# -*- coding: utf-8 -*-
"""personalised spotify recommendation engine (infotact 2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RylVY00TzRrv4MidvVSb3hyclPmef9t5
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.manifold import TSNE
from sklearn.metrics.pairwise import cosine_similarity

csv_path = os.path.join('Clean_spotify_2023.csv')
spotify_df = pd.read_csv(csv_path)

feature_columns = [
    'bpm', 'danceability_%', 'valence_%', 'energy_%',
    'acousticness_%', 'instrumentalness_%', 'liveness_%', 'speechiness_%'
]

spotify_df[feature_columns] = spotify_df[feature_columns].apply(pd.to_numeric, errors='coerce')

spotify_df = spotify_df.dropna(subset=feature_columns).reset_index(drop=True)

scaler = MinMaxScaler()
normalized_features = scaler.fit_transform(spotify_df[feature_columns])

tsne = TSNE(n_components=2, random_state=42, perplexity=30, n_iter=500)
tsne_results = tsne.fit_transform(normalized_features)

plt.figure(figsize=(10, 6))
plt.scatter(tsne_results[:, 0], tsne_results[:, 1], s=10, alpha=0.7)
plt.title("t‑SNE of Spotify Track Audio Features")
plt.xlabel("t‑SNE 1")
plt.ylabel("t‑SNE 2")
plt.grid(True)
plt.show()

# 4. Heatmap of cosine similarities (sample of 30 tracks)
# ------------------------------------------------------------------
sample_size = 30
sample_indices = list(range(sample_size))
sample_tracks = spotify_df.iloc[sample_indices]['track_name'].tolist()

similarity_matrix = cosine_similarity(normalized_features[sample_indices])

plt.figure(figsize=(8, 6))
plt.imshow(similarity_matrix, aspect='auto')
plt.colorbar(label="Cosine Similarity")
plt.title("Similarity Heatmap (First 30 Tracks)")
plt.xticks(ticks=range(sample_size), labels=range(1, sample_size + 1), rotation=90)
plt.yticks(ticks=range(sample_size), labels=range(1, sample_size + 1))
plt.tight_layout()
plt.show()

# 5. Radar chart comparing two songs
# ------------------------------------------------------------------
def radar_plot(song_a, song_b, df, features, scaler_obj):
    # Fetch rows
    try:
        idx_a = df[df['track_name'].str.lower() == song_a.lower()].index[0]
        idx_b = df[df['track_name'].str.lower() == song_b.lower()].index[0]
    except IndexError:
        print(f"One of the songs ('{song_a}', '{song_b}') not found in dataset.")
        return

    values_a = scaler_obj.transform([df.loc[idx_a, features]])[0]
    values_b = scaler_obj.transform([df.loc[idx_b, features]])[0]

    # Setup radar plot
    angles = np.linspace(0, 2 * np.pi, len(features), endpoint=False).tolist()
    angles += angles[:1]  # close the circle

    values_a = np.concatenate((values_a, [values_a[0]]))
    values_b = np.concatenate((values_b, [values_b[0]]))

    fig, ax = plt.subplots(subplot_kw=dict(polar=True), figsize=(8, 6))

    ax.plot(angles, values_a, linewidth=2, label=song_a)
    ax.fill(angles, values_a, alpha=0.25)

    ax.plot(angles, values_b, linewidth=2, label=song_b)
    ax.fill(angles, values_b, alpha=0.25)

    ax.set_thetagrids(np.degrees(angles[:-1]), features, fontsize=8)
    ax.set_title(f"Audio Feature Radar Chart:\n'{song_a}' vs. '{song_b}'", pad=20)
    ax.legend(loc='upper right', bbox_to_anchor=(1.1, 1.1))
    plt.show()

# Pick two popular songs present in the dataset
song1 = "Shape of You"
song2_candidates = ["Perfect", "Thinking Out Loud", "Blinding Lights", "Stay With Me"]
song2 = None
for cand in song2_candidates:
    if cand.lower() in spotify_df['track_name'].str.lower().values:
        song2 = cand
        break
if song2 is None:
    song2 = spotify_df.loc[1, 'track_name']

radar_plot(song1, song2, spotify_df, feature_columns, scaler)

feature_columns = [
    'bpm', 'danceability_%', 'valence_%', 'energy_%',
    'acousticness_%', 'instrumentalness_%', 'liveness_%', 'speechiness_%'
]
features = spotify_df[feature_columns]
scaler = MinMaxScaler()
normalized_features = scaler.fit_transform(features)

similarity_matrix = cosine_similarity(normalized_features)

popularity_score = MinMaxScaler().fit_transform(spotify_df[['streams']])

alpha = 0.7  # weight for content similarity
beta = 0.3   # weight for popularity

def hybrid_recommend(track_name, top_n=5):
    try:
        index = spotify_df[spotify_df['track_name'].str.lower() == track_name.lower()].index[0]
    except IndexError:
        return f"Track '{track_name}' not found in the dataset."

    # Content-based similarity scores
    sim_scores = similarity_matrix[index]

    # Combine with popularity scores
    hybrid_scores = alpha * sim_scores + beta * popularity_score.reshape(-1)

    # Get top N recommendations excluding the original track
    recommended_indices = np.argsort(hybrid_scores)[::-1]
    recommended_indices = [i for i in recommended_indices if i != index][:top_n]

    return spotify_df.iloc[recommended_indices][['track_name', 'artist(s)_name', 'streams']]

sample_recommendations = hybrid_recommend("heat waves", top_n=5)
print(sample_recommendations)